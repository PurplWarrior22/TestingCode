// Package swagger provides primitives to interact with the openapi HTTP API.
//
// Code generated by  version  DO NOT EDIT.
package swagger

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for MaintenanceImageStatus.
const (
	MaintenanceImageStatusFMC MaintenanceImageStatus = "FMC"

	MaintenanceImageStatusNMC MaintenanceImageStatus = "NMC"

	MaintenanceImageStatusPMC MaintenanceImageStatus = "PMC"
)

// Error defines model for Error.
type Error struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

// A single madden image containing enough details to specify system status and a link to the image
type MaintenanceImage struct {
	// identifier of the madden image
	Id int `json:"id"`

	// a link to an image
	ImageLink *string `json:"imageLink,omitempty"`

	// a status enum indicating the system status this image is associated with
	Status MaintenanceImageStatus `json:"status"`

	// a link to an image thumbnail
	ThumbnailLink *string `json:"thumbnailLink,omitempty"`
}

// a status enum indicating the system status this image is associated with
type MaintenanceImageStatus string

// A single madden item
type MaintenanceItem struct {
	// additional details about the madden item
	Details string `json:"details"`

	// time when the madden ends
	EndDate string `json:"endDate"`

	// a historical flag for this entry
	Historical *bool `json:"historical,omitempty"`

	// a unique identifier for this madden entry
	Id *int `json:"id,omitempty"`

	// An array of one to two links to associated madden images
	Images []MaintenanceImage `json:"images"`

	// time when the madden began
	StartDate string `json:"startDate"`

	// An explanation of the reason or other information about this maddenItem
	Summary string `json:"summary"`
}

// MaintenanceItems defines model for MaintenanceItems.
type MaintenanceItems struct {
	// an array of madden entry
	Entries []MaintenanceItem `json:"entries"`
}

// Published defines model for Published.
type Published struct {
	// whether madden is in the publish or edit state
	Published bool `json:"published"`
}

// Summary defines model for Summary.
type Summary struct {
	// an overall system madden summary
	Summary string `json:"summary"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse Error

// GetEntryParams defines parameters for GetEntry.
type GetEntryParams struct {
	// page number to retrieve defaults to 0
	PageNumber *int `json:"pageNumber,omitempty"`

	// page size to retrieve defaults to 25
	PageSize *int `json:"pageSize,omitempty"`

	// the id of an item to retrieve, if provided only the single item that matches this id will returned
	Id *int `json:"id,omitempty"`

	// if provided, all entries returned will have a start date equal or greater than the supplied date format is RFC3339
	StartDate *string `json:"startDate,omitempty"`

	// if provided, all entries returned will have an end date less than or equal to the supplied date format is RFC3339
	EndDate *string `json:"endDate,omitempty"`

	// field to sort on, defaults to startDate, must be one of startDate, endDate
	Sort *GetEntryParamsSort `json:"sort,omitempty"`

	// if provided will sort on historic on non-historic items
	Historic *GetEntryParamsHistoric `json:"historic,omitempty"`
}

// GetEntryParamsSort defines parameters for GetEntry.
type GetEntryParamsSort string

// GetEntryParamsHistoric defines parameters for GetEntry.
type GetEntryParamsHistoric string

// PostEntryJSONBody defines parameters for PostEntry.
type PostEntryJSONBody MaintenanceItem

// PutEntryMaintenanceIdJSONBody defines parameters for PutEntryMaintenanceId.
type PutEntryMaintenanceIdJSONBody MaintenanceItem

// PostPublishedJSONBody defines parameters for PostPublished.
type PostPublishedJSONBody Published

// PostSummaryJSONBody defines parameters for PostSummary.
type PostSummaryJSONBody Summary

// PostEntryJSONRequestBody defines body for PostEntry for application/json ContentType.
type PostEntryJSONRequestBody PostEntryJSONBody

// PutEntryMaintenanceIdJSONRequestBody defines body for PutEntryMaintenanceId for application/json ContentType.
type PutEntryMaintenanceIdJSONRequestBody PutEntryMaintenanceIdJSONBody

// PostPublishedJSONRequestBody defines body for PostPublished for application/json ContentType.
type PostPublishedJSONRequestBody PostPublishedJSONBody

// PostSummaryJSONRequestBody defines body for PostSummary for application/json ContentType.
type PostSummaryJSONRequestBody PostSummaryJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetEntry request
	GetEntry(ctx context.Context, params *GetEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEntry request with any body
	PostEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEntry(ctx context.Context, body PostEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEntryMaintenanceId request
	DeleteEntryMaintenanceId(ctx context.Context, maddenId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutEntryMaintenanceId request with any body
	PutEntryMaintenanceIdWithBody(ctx context.Context, maddenId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutEntryMaintenanceId(ctx context.Context, maddenId int, body PutEntryMaintenanceIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublished request
	GetPublished(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPublished request with any body
	PostPublishedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPublished(ctx context.Context, body PostPublishedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSummary request
	GetSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSummary request with any body
	PostSummaryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSummary(ctx context.Context, body PostSummaryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetEntry(ctx context.Context, params *GetEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEntryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEntry(ctx context.Context, body PostEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEntryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEntryMaintenanceId(ctx context.Context, maddenId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEntryMaintenanceIdRequest(c.Server, maddenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutEntryMaintenanceIdWithBody(ctx context.Context, maddenId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutEntryMaintenanceIdRequestWithBody(c.Server, maddenId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutEntryMaintenanceId(ctx context.Context, maddenId int, body PutEntryMaintenanceIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutEntryMaintenanceIdRequest(c.Server, maddenId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublished(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublishedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPublishedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPublishedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPublished(ctx context.Context, body PostPublishedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPublishedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSummaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSummaryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSummaryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSummary(ctx context.Context, body PostSummaryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSummaryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetEntryRequest generates requests for GetEntry
func NewGetEntryRequest(server string, params *GetEntryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageNumber", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Historic != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "historic", runtime.ParamLocationQuery, *params.Historic); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEntryRequest calls the generic PostEntry builder with application/json body
func NewPostEntryRequest(server string, body PostEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEntryRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEntryRequestWithBody generates requests for PostEntry with any type of body
func NewPostEntryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEntryMaintenanceIdRequest generates requests for DeleteEntryMaintenanceId
func NewDeleteEntryMaintenanceIdRequest(server string, maddenId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "maddenId", runtime.ParamLocationPath, maddenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutEntryMaintenanceIdRequest calls the generic PutEntryMaintenanceId builder with application/json body
func NewPutEntryMaintenanceIdRequest(server string, maddenId int, body PutEntryMaintenanceIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutEntryMaintenanceIdRequestWithBody(server, maddenId, "application/json", bodyReader)
}

// NewPutEntryMaintenanceIdRequestWithBody generates requests for PutEntryMaintenanceId with any type of body
func NewPutEntryMaintenanceIdRequestWithBody(server string, maddenId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "maddenId", runtime.ParamLocationPath, maddenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPublishedRequest generates requests for GetPublished
func NewGetPublishedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/published")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPublishedRequest calls the generic PostPublished builder with application/json body
func NewPostPublishedRequest(server string, body PostPublishedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPublishedRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPublishedRequestWithBody generates requests for PostPublished with any type of body
func NewPostPublishedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/published")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSummaryRequest generates requests for GetSummary
func NewGetSummaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSummaryRequest calls the generic PostSummary builder with application/json body
func NewPostSummaryRequest(server string, body PostSummaryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSummaryRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSummaryRequestWithBody generates requests for PostSummary with any type of body
func NewPostSummaryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetEntry request
	GetEntryWithResponse(ctx context.Context, params *GetEntryParams, reqEditors ...RequestEditorFn) (*GetEntryResponse, error)

	// PostEntry request with any body
	PostEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEntryResponse, error)

	PostEntryWithResponse(ctx context.Context, body PostEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEntryResponse, error)

	// DeleteEntryMaintenanceId request
	DeleteEntryMaintenanceIdWithResponse(ctx context.Context, maddenId int, reqEditors ...RequestEditorFn) (*DeleteEntryMaintenanceIdResponse, error)

	// PutEntryMaintenanceId request with any body
	PutEntryMaintenanceIdWithBodyWithResponse(ctx context.Context, maddenId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutEntryMaintenanceIdResponse, error)

	PutEntryMaintenanceIdWithResponse(ctx context.Context, maddenId int, body PutEntryMaintenanceIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutEntryMaintenanceIdResponse, error)

	// GetPublished request
	GetPublishedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPublishedResponse, error)

	// PostPublished request with any body
	PostPublishedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPublishedResponse, error)

	PostPublishedWithResponse(ctx context.Context, body PostPublishedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPublishedResponse, error)

	// GetSummary request
	GetSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSummaryResponse, error)

	// PostSummary request with any body
	PostSummaryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSummaryResponse, error)

	PostSummaryWithResponse(ctx context.Context, body PostSummaryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSummaryResponse, error)
}

type GetEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MaintenanceItems
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MaintenanceItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEntryMaintenanceIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteEntryMaintenanceIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEntryMaintenanceIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutEntryMaintenanceIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MaintenanceItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutEntryMaintenanceIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutEntryMaintenanceIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublishedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Published
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPublishedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublishedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPublishedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Published
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostPublishedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPublishedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Summary
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Summary
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetEntryWithResponse request returning *GetEntryResponse
func (c *ClientWithResponses) GetEntryWithResponse(ctx context.Context, params *GetEntryParams, reqEditors ...RequestEditorFn) (*GetEntryResponse, error) {
	rsp, err := c.GetEntry(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntryResponse(rsp)
}

// PostEntryWithBodyWithResponse request with arbitrary body returning *PostEntryResponse
func (c *ClientWithResponses) PostEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEntryResponse, error) {
	rsp, err := c.PostEntryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEntryResponse(rsp)
}

func (c *ClientWithResponses) PostEntryWithResponse(ctx context.Context, body PostEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEntryResponse, error) {
	rsp, err := c.PostEntry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEntryResponse(rsp)
}

// DeleteEntryMaintenanceIdWithResponse request returning *DeleteEntryMaintenanceIdResponse
func (c *ClientWithResponses) DeleteEntryMaintenanceIdWithResponse(ctx context.Context, maddenId int, reqEditors ...RequestEditorFn) (*DeleteEntryMaintenanceIdResponse, error) {
	rsp, err := c.DeleteEntryMaintenanceId(ctx, maddenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEntryMaintenanceIdResponse(rsp)
}

// PutEntryMaintenanceIdWithBodyWithResponse request with arbitrary body returning *PutEntryMaintenanceIdResponse
func (c *ClientWithResponses) PutEntryMaintenanceIdWithBodyWithResponse(ctx context.Context, maddenId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutEntryMaintenanceIdResponse, error) {
	rsp, err := c.PutEntryMaintenanceIdWithBody(ctx, maddenId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutEntryMaintenanceIdResponse(rsp)
}

func (c *ClientWithResponses) PutEntryMaintenanceIdWithResponse(ctx context.Context, maddenId int, body PutEntryMaintenanceIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutEntryMaintenanceIdResponse, error) {
	rsp, err := c.PutEntryMaintenanceId(ctx, maddenId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutEntryMaintenanceIdResponse(rsp)
}

// GetPublishedWithResponse request returning *GetPublishedResponse
func (c *ClientWithResponses) GetPublishedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPublishedResponse, error) {
	rsp, err := c.GetPublished(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublishedResponse(rsp)
}

// PostPublishedWithBodyWithResponse request with arbitrary body returning *PostPublishedResponse
func (c *ClientWithResponses) PostPublishedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPublishedResponse, error) {
	rsp, err := c.PostPublishedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPublishedResponse(rsp)
}

func (c *ClientWithResponses) PostPublishedWithResponse(ctx context.Context, body PostPublishedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPublishedResponse, error) {
	rsp, err := c.PostPublished(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPublishedResponse(rsp)
}

// GetSummaryWithResponse request returning *GetSummaryResponse
func (c *ClientWithResponses) GetSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSummaryResponse, error) {
	rsp, err := c.GetSummary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSummaryResponse(rsp)
}

// PostSummaryWithBodyWithResponse request with arbitrary body returning *PostSummaryResponse
func (c *ClientWithResponses) PostSummaryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSummaryResponse, error) {
	rsp, err := c.PostSummaryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSummaryResponse(rsp)
}

func (c *ClientWithResponses) PostSummaryWithResponse(ctx context.Context, body PostSummaryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSummaryResponse, error) {
	rsp, err := c.PostSummary(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSummaryResponse(rsp)
}

// ParseGetEntryResponse parses an HTTP response from a GetEntryWithResponse call
func ParseGetEntryResponse(rsp *http.Response) (*GetEntryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MaintenanceItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEntryResponse parses an HTTP response from a PostEntryWithResponse call
func ParsePostEntryResponse(rsp *http.Response) (*PostEntryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MaintenanceItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEntryMaintenanceIdResponse parses an HTTP response from a DeleteEntryMaintenanceIdWithResponse call
func ParseDeleteEntryMaintenanceIdResponse(rsp *http.Response) (*DeleteEntryMaintenanceIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEntryMaintenanceIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutEntryMaintenanceIdResponse parses an HTTP response from a PutEntryMaintenanceIdWithResponse call
func ParsePutEntryMaintenanceIdResponse(rsp *http.Response) (*PutEntryMaintenanceIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutEntryMaintenanceIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MaintenanceItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPublishedResponse parses an HTTP response from a GetPublishedWithResponse call
func ParseGetPublishedResponse(rsp *http.Response) (*GetPublishedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublishedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Published
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostPublishedResponse parses an HTTP response from a PostPublishedWithResponse call
func ParsePostPublishedResponse(rsp *http.Response) (*PostPublishedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPublishedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Published
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSummaryResponse parses an HTTP response from a GetSummaryWithResponse call
func ParseGetSummaryResponse(rsp *http.Response) (*GetSummaryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Summary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSummaryResponse parses an HTTP response from a PostSummaryWithResponse call
func ParsePostSummaryResponse(rsp *http.Response) (*PostSummaryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Summary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get madden items, optionally filtered with query string
	// (GET /entry)
	GetEntry(ctx echo.Context, params GetEntryParams) error
	// create a new madden item
	// (POST /entry)
	PostEntry(ctx echo.Context) error
	// delete an entry
	// (DELETE /entry/{maddenId})
	DeleteEntryMaintenanceId(ctx echo.Context, maddenId int) error
	// update and existing madden item
	// (PUT /entry/{maddenId})
	PutEntryMaintenanceId(ctx echo.Context, maddenId int) error

	// (GET /published)
	GetPublished(ctx echo.Context) error

	// (POST /published)
	PostPublished(ctx echo.Context) error

	// (GET /summary)
	GetSummary(ctx echo.Context) error

	// (POST /summary)
	PostSummary(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetEntry converts echo context to params.
func (w *ServerInterfaceWrapper) GetEntry(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntryParams
	// ------------- Optional query parameter "pageNumber" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageNumber", ctx.QueryParams(), &params.PageNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageNumber: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", ctx.QueryParams(), &params.StartDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startDate: %s", err))
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", ctx.QueryParams(), &params.EndDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endDate: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "historic" -------------

	err = runtime.BindQueryParameter("form", true, false, "historic", ctx.QueryParams(), &params.Historic)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter historic: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEntry(ctx, params)
	return err
}

// PostEntry converts echo context to params.
func (w *ServerInterfaceWrapper) PostEntry(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostEntry(ctx)
	return err
}

// DeleteEntryMaintenanceId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEntryMaintenanceId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "maddenId" -------------
	var maddenId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "maddenId", runtime.ParamLocationPath, ctx.Param("maddenId"), &maddenId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maddenId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteEntryMaintenanceId(ctx, maddenId)
	return err
}

// PutEntryMaintenanceId converts echo context to params.
func (w *ServerInterfaceWrapper) PutEntryMaintenanceId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "maddenId" -------------
	var maddenId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "maddenId", runtime.ParamLocationPath, ctx.Param("maddenId"), &maddenId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maddenId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutEntryMaintenanceId(ctx, maddenId)
	return err
}

// GetPublished converts echo context to params.
func (w *ServerInterfaceWrapper) GetPublished(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPublished(ctx)
	return err
}

// PostPublished converts echo context to params.
func (w *ServerInterfaceWrapper) PostPublished(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostPublished(ctx)
	return err
}

// GetSummary converts echo context to params.
func (w *ServerInterfaceWrapper) GetSummary(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSummary(ctx)
	return err
}

// PostSummary converts echo context to params.
func (w *ServerInterfaceWrapper) PostSummary(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostSummary(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/entry", wrapper.GetEntry)
	router.POST(baseURL+"/entry", wrapper.PostEntry)
	router.DELETE(baseURL+"/entry/:maddenId", wrapper.DeleteEntryMaintenanceId)
	router.PUT(baseURL+"/entry/:maddenId", wrapper.PutEntryMaintenanceId)
	router.GET(baseURL+"/published", wrapper.GetPublished)
	router.POST(baseURL+"/published", wrapper.PostPublished)
	router.GET(baseURL+"/summary", wrapper.GetSummary)
	router.POST(baseURL+"/summary", wrapper.PostSummary)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

